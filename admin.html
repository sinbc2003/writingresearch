<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WritingResearch 관리자</title>
    <style>
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: 'Pretendard', 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: #f7fafc;
        color: #1f2937;
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding: 40px 16px;
      }
      .container {
        width: min(1200px, 100%);
        background: #ffffff;
        border: 1px solid #e2e8f0;
        border-radius: 18px;
        padding: 32px;
        box-shadow: 0 24px 48px rgba(15, 23, 42, 0.12);
      }
      h1, h2, h3 {
        margin: 0;
        color: #0f172a;
      }
      h1 { font-size: 26px; margin-bottom: 20px; }
      h2 { font-size: 20px; margin-bottom: 14px; }
      h3 { font-size: 16px; margin-bottom: 8px; }
      label { display: block; font-size: 13px; margin-bottom: 6px; color: #475569; font-weight: 600; }
      input, textarea, select {
        width: 100%;
        padding: 10px 14px;
        border-radius: 10px;
        border: 1px solid #cbd5f5;
        background: #ffffff;
        color: #1f2937;
        font-size: 14px;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }
      input:focus, textarea:focus, select:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
      }
      textarea { min-height: 140px; resize: vertical; }
      button {
        border: none;
        border-radius: 10px;
        padding: 10px 16px;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }
      button.primary {
        background: linear-gradient(135deg, #2563eb, #1d4ed8);
        color: #ffffff;
      }
      button.secondary {
        background: #eef2ff;
        color: #1e3a8a;
      }
      button.danger {
        background: linear-gradient(135deg, #ef4444, #dc2626);
        color: #ffffff;
      }
      button:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; }
      button:not(:disabled):hover { transform: translateY(-1px); box-shadow: 0 10px 24px rgba(37, 99, 235, 0.18); }
      .card {
        border-radius: 16px;
        border: 1px solid #e2e8f0;
        background: #ffffff;
        padding: 20px;
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.08);
      }
      .card + .card { margin-top: 24px; }
      .grid {
        display: grid;
        gap: 20px;
      }
      .grid-2 {
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }
      .status-bar {
        margin-bottom: 20px;
        padding: 12px 16px;
        border-radius: 12px;
        background: #e0f2fe;
        border: 1px solid #93c5fd;
        font-size: 13px;
        color: #1d4ed8;
      }
      .status-bar.error {
        background: #fee2e2;
        border-color: #fca5a5;
        color: #b91c1c;
      }
      .status-bar.success {
        background: #dcfce7;
        border-color: #86efac;
        color: #15803d;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 13px;
      }
      th, td {
        padding: 10px 12px;
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
        text-align: left;
      }
      tr { cursor: pointer; }
      tr:hover { background: rgba(59, 130, 246, 0.1); }
      tr.active { background: rgba(37, 99, 235, 0.22); }
      .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
      }
      .badge.openai { background: rgba(37, 99, 235, 0.2); color: #bfdbfe; }
      .badge.disabled { background: #e2e8f0; color: #475569; }
      .badge.stage { background: #dbeafe; color: #1d4ed8; }
      .badge.group { background: #fee2e2; color: #b91c1c; }
      .toolbar {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        margin-bottom: 16px;
      }
      pre {
        white-space: pre-wrap;
        word-break: break-word;
        margin: 0;
        font-size: 13px;
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        padding: 14px;
        max-height: 320px;
        overflow-y: auto;
      }
      .match-form {
        display: grid;
        gap: 16px;
      }
      .match-form textarea {
        width: 100%;
        min-height: 100px;
        resize: vertical;
        font-family: inherit;
      }
      .match-actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .export-options {
        display: grid;
        gap: 8px;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        margin-top: 12px;
      }
      .export-option {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        border: 1px solid #e2e8f0;
        border-radius: 10px;
        background: #f8fafc;
        font-size: 13px;
      }
      .export-option input {
        width: auto;
        cursor: pointer;
      }
      .session-search {
        margin-bottom: 16px;
      }
      .session-search label {
        font-weight: 600;
        margin-bottom: 8px;
        display: block;
      }
      .session-search-row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .session-search-row input {
        flex: 1 1 280px;
      }
      .quick-match-grid {
        display: grid;
        gap: 16px;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        margin-top: 16px;
      }
      .quick-match-panel {
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        background: #f8fafc;
        padding: 16px;
      }
      .quick-match-summary {
        margin-top: 12px;
        font-size: 13px;
        line-height: 1.5;
      }
      .quick-match-summary strong {
        display: block;
        font-size: 15px;
        color: #0f172a;
        margin-bottom: 4px;
      }
      .quick-match-actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 16px;
        justify-content: flex-end;
      }
      .unmatched-list {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 16px;
      }
      .unmatched-chip {
        border: 1px solid #cbd5f5;
        background: #eef2ff;
        color: #1e3a8a;
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 12px;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease;
      }
      .unmatched-chip:hover {
        background: #dbeafe;
        transform: translateY(-1px);
      }
      .unmatched-chip.selected {
        background: #2563eb;
        color: #ffffff;
        border-color: #2563eb;
      }
      .file-button {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        padding: 10px 16px;
        border-radius: 10px;
        border: 1px solid #cbd5f5;
        background: #eef2ff;
        color: #1e3a8a;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }
      .file-button:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 24px rgba(37, 99, 235, 0.14);
      }
      .file-button input {
        position: absolute;
        inset: 0;
        opacity: 0;
        cursor: pointer;
      }
      .prompt-preview {
        margin-top: 12px;
        padding: 16px;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        background: #f8fafc;
        font-size: 14px;
        line-height: 1.7;
        white-space: pre-wrap;
      }
      .prompt-preview.empty {
        color: #64748b;
        font-style: italic;
      }
      .detail-heading {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }
      .detail-id {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .detail-id strong { font-size: 18px; color: #0f172a; }
      .detail-label {
        font-size: 12px;
        color: #64748b;
        font-weight: 600;
        letter-spacing: 0.04em;
        text-transform: uppercase;
      }
      .detail-info-grid {
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        margin-top: 16px;
      }
      .detail-info-grid p { margin: 4px 0 0; }
      .detail-partner-block {
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        padding: 16px;
        margin-top: 20px;
      }
      .detail-partner-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }
      .match-buttons {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 12px;
      }
      .link-button {
        background: none;
        border: none;
        color: #2563eb;
        font-weight: 600;
        cursor: pointer;
        padding: 6px 10px;
        border-radius: 8px;
      }
      .link-button:hover {
        background: rgba(37, 99, 235, 0.12);
      }
      .stage-list {
        display: grid;
        gap: 16px;
        margin-top: 24px;
      }
      .stage-block {
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        padding: 16px;
        background: #ffffff;
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.06);
      }
      .stage-title {
        font-weight: 700;
        margin-bottom: 6px;
        color: #0f172a;
      }
      .stage-meta {
        font-size: 12px;
        color: #64748b;
        margin-bottom: 10px;
      }
      #sessionDetail pre { margin: 0; }
      .hidden { display: none !important; }
      .muted { color: #64748b; font-size: 12px; }
      @media (max-width: 960px) {
        body { padding: 24px 10px; }
        .container { padding: 24px; }
        .flex { flex-direction: column; }
      }
    </style>
    <script src="./app-config.js"></script>
  </head>
  <body>
    <div class="container">
      <div id="statusBar" class="status-bar">관리자 비밀번호를 입력하세요.</div>

      <div id="loginView">
        <h1>WritingResearch 관리자 로그인</h1>
        <div class="card" style="max-width: 420px; margin-top: 20px;">
          <label for="adminPassword">관리자 비밀번호</label>
          <input id="adminPassword" type="password" placeholder="관리자 비밀번호" />
          <div style="margin-top: 16px; display: flex; gap: 10px;">
            <button id="btnLogin" class="primary" type="button">로그인</button>
            <button id="btnClearStored" class="secondary" type="button">저장된 토큰 삭제</button>
          </div>
        </div>
      </div>

      <datalist id="sessionOptions"></datalist>

      <div id="adminView" class="hidden">
        <div class="toolbar">
          <button id="btnReloadSessions" class="secondary" type="button">세션 새로고침</button>
          <button id="btnReloadConfig" class="secondary" type="button">설정 새로고침</button>
          <button id="btnLogout" class="danger" type="button">로그아웃</button>
        </div>

        <section class="card" id="exportSection">
          <h2>데이터 다운로드</h2>
          <p class="muted" style="margin-bottom: 12px;">내려받을 항목을 선택한 후 <strong>선택 항목 다운로드</strong> 버튼을 눌러주세요. 파일은 Excel(xlsx) 형식으로 저장됩니다.</p>
          <div class="export-options">
            <label class="export-option">
              <input type="checkbox" id="exportScopeAll" data-export-scope value="all" checked />
              <span>세션 전체 (요약 포함)</span>
            </label>
            <label class="export-option">
              <input type="checkbox" id="exportScopeAi" data-export-scope value="ai-chat" checked />
              <span>AI 피드백 대화</span>
            </label>
            <label class="export-option">
              <input type="checkbox" id="exportScopeStage1" data-export-scope value="stage1" checked />
              <span>1단계 · 사전 글쓰기</span>
            </label>
            <label class="export-option">
              <input type="checkbox" id="exportScopeStage2" data-export-scope value="stage2" checked />
              <span>2단계 · 수정 아이디어 메모</span>
            </label>
            <label class="export-option">
              <input type="checkbox" id="exportScopeStage3" data-export-scope value="stage3" checked />
              <span>3단계 · 동료 피드백 메모</span>
            </label>
            <label class="export-option">
              <input type="checkbox" id="exportScopeStage4" data-export-scope value="final" checked />
              <span>최종 글</span>
            </label>
          </div>
          <div class="match-actions" style="margin-top: 16px; justify-content: flex-end;">
            <button id="btnDownloadExport" class="primary" type="button">선택 항목 다운로드</button>
          </div>
        </section>

        <section class="card">
          <h2>AI 설정</h2>
          <p class="muted" style="margin-bottom: 16px;">OpenAI 키 입력 시 자동으로 OpenAI가 사용되며, 비워두면 기존 키를 유지합니다.</p>
          <div class="grid grid-2">
            <div>
              <label for="aiProvider">AI 제공자</label>
              <select id="aiProvider">
                <option value="auto">자동 선택</option>
                <option value="openai">OpenAI</option>
                <option value="none">비활성화</option>
              </select>
            </div>
            <div>
              <label for="aiTemperature">Temperature (0~1)</label>
              <input id="aiTemperature" type="number" step="0.05" min="0" max="1" placeholder="0.6" />
            </div>
          </div>
          <div style="margin-top: 16px;">
            <label for="aiSystemPrompt">System Prompt</label>
            <textarea id="aiSystemPrompt" placeholder="AI 기본 지침을 입력하세요."></textarea>
          </div>

          <div class="grid grid-2" style="margin-top: 20px;">
            <div>
              <h3>OpenAI</h3>
              <label for="openaiModel">모델 이름</label>
              <input id="openaiModel" type="text" placeholder="예: gpt-4o-mini" />
              <label for="openaiBaseUrl" style="margin-top: 12px;">Base URL</label>
              <input id="openaiBaseUrl" type="text" placeholder="https://api.openai.com/v1" />
              <label for="openaiOrg" style="margin-top: 12px;">조직 ID</label>
              <input id="openaiOrg" type="text" placeholder="Optional" />
              <label for="openaiApiKey" style="margin-top: 12px;">새 API 키</label>
              <input id="openaiApiKey" type="password" placeholder="새 키 입력 (비워두면 유지)" />
              <button id="btnClearOpenAiKey" class="secondary" type="button" style="margin-top: 10px;">저장된 OpenAI 키 제거</button>
            </div>
          </div>

          <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
            <button id="btnSaveConfig" class="primary" type="button">설정 저장</button>
          </div>
        </section>

        <section class="card" id="promptSection">
          <h2>제시문 관리</h2>
          <p class="muted" style="margin-bottom: 12px;">학생들이 1단계에서 확인하는 제시문을 입력하세요. 저장하면 즉시 적용되며, 학생 화면은 새로고침 후 반영됩니다.</p>
          <textarea id="promptTextarea" placeholder="제시문 내용을 입력하세요."></textarea>
          <div class="match-actions" style="margin-top: 16px; justify-content: flex-end;">
            <button id="btnPromptReload" class="secondary" type="button">현재 제시문 불러오기</button>
            <button id="btnPromptSave" class="primary" type="button" disabled>제시문 저장</button>
          </div>
          <div class="muted" style="margin-top: 20px;">미리보기</div>
          <div id="promptPreview" class="prompt-preview empty">제시문이 아직 등록되지 않았습니다.</div>
        </section>

        <section class="card" id="quickMatchSection">
          <h2>빠른 동료 매칭</h2>
          <p class="muted" style="margin-bottom: 12px;">서로 다른 두 세션을 선택해 빠르게 매칭하세요. 아래 목록에서 미매칭 학생을 클릭하면 입력란에 자동으로 채워집니다.</p>
          <div class="quick-match-grid">
            <div class="quick-match-panel">
              <label for="quickMatchPrimary">학생 A 세션</label>
              <input id="quickMatchPrimary" type="text" list="sessionOptions" placeholder="세션 키 또는 학생 이름/식별 번호" autocomplete="off" />
              <div class="quick-match-summary" id="quickMatchPrimarySummary">세션을 선택하세요.</div>
            </div>
            <div class="quick-match-panel">
              <label for="quickMatchPartner">학생 B 세션</label>
              <input id="quickMatchPartner" type="text" list="sessionOptions" placeholder="세션 키 또는 학생 이름/식별 번호" autocomplete="off" />
              <div class="quick-match-summary" id="quickMatchPartnerSummary">세션을 선택하세요.</div>
            </div>
          </div>
          <div class="quick-match-actions">
            <button id="btnQuickMatchSwap" class="secondary" type="button">A ↔ B 교환</button>
            <button id="btnQuickMatchClear" class="secondary" type="button">선택 초기화</button>
            <button id="btnQuickMatchApply" class="primary" type="button" disabled>서로 매칭</button>
          </div>
          <div class="muted" style="margin-top: 20px;">미매칭 세션</div>
          <div class="unmatched-list" id="quickMatchUnmatchedList"></div>
        </section>

        <section class="card hidden" id="partnerSection">
          <h2>동료 매칭</h2>
          <p class="muted" style="margin-bottom: 12px;">세션을 선택한 후 동료의 세션 키를 지정하거나 이름/식별 번호를 직접 입력해 매칭하세요.</p>
          <textarea id="partnerBulkInput" placeholder="세션키, 이름, 식별번호 순으로 한 줄에 입력하세요.
예) SessionA, 홍길동, A10100"></textarea>
          <div class="match-actions" style="margin-top: 16px;">
            <button id="btnParseBulk" class="secondary" type="button">붙여넣기 분석</button>
            <button id="btnAssignPartner" class="primary" type="button" disabled>동료 저장</button>
            <button id="btnClearPartner" class="secondary" type="button" disabled>동료 연결 해제</button>
            <button id="btnJumpPartner" class="link-button" type="button" disabled>동료 세션 열기</button>
          </div>
        </section>

        <section class="card" id="rosterSection">
          <h2>학생 명단</h2>
          <p class="muted" style="margin-bottom: 12px;">식별번호와 이름을 한 줄씩 입력하거나 붙여넣으세요. 중복은 자동으로 정리됩니다.</p>
          <textarea id="rosterTextarea" placeholder="식별번호, 이름"></textarea>
          <div class="match-actions" style="margin-top: 16px; align-items: center;">
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
              <button id="btnRosterSave" class="primary" type="button">명단 저장</button>
              <button id="btnRosterReload" class="secondary" type="button">명단 새로고침</button>
              <button id="btnRosterDownloadTemplate" class="secondary" type="button">CSV 템플릿 다운로드</button>
              <button id="btnApplyCsvPairings" class="secondary" type="button" disabled>CSV 동료 매칭 적용</button>
              <label class="file-button" style="margin: 0;">
                CSV 업로드
                <input id="rosterFileInput" type="file" accept=".csv,text/csv" />
              </label>
              <button id="btnRosterClear" class="danger" type="button">명단 비우기</button>
            </div>
            <span class="muted" id="rosterCountLabel" style="margin-left: auto;">등록된 학생 0명</span>
          </div>
        </section>

        <section class="card" id="sessionListSection">
          <h2>세션 목록</h2>
          <div class="muted" style="margin-bottom: 12px;">목록에서 세션을 선택하면 상세 정보와 대화 로그를 확인하고 동료를 매칭할 수 있습니다.</div>
          <div class="session-search">
            <label for="sessionSearchInput">세션 빠르게 찾기</label>
            <div class="session-search-row">
              <input id="sessionSearchInput" type="text" list="sessionOptions" placeholder="세션 키 또는 학생 이름/식별 번호를 입력하세요." autocomplete="off" />
              <button id="btnSelectSession" class="secondary" type="button">세션 열기</button>
            </div>
          </div>
          <div class="match-actions" style="margin-bottom: 12px; flex-wrap: wrap;">
            <button id="btnDeleteSelectedSession" class="danger" type="button" disabled>선택한 세션 삭제</button>
            <button id="btnDeleteAllSessions" class="danger" type="button" disabled>세션 전체 삭제</button>
            <button id="btnDeleteUnmatchedSessions" class="secondary" type="button" disabled>미매칭 세션 삭제</button>
          </div>
          <div style="overflow-x: auto;">
            <table id="sessionTable">
              <thead>
                <tr>
                  <th style="width: 42px;"><input type="checkbox" id="sessionSelectAll" /></th>
                  <th>세션</th>
                  <th>집단</th>
                  <th>학생</th>
                  <th>단계</th>
                  <th>동료</th>
                  <th>업데이트</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </section>

        <section class="card hidden" id="sessionDetailSection">
          <h2>세션 상세</h2>
          <div id="sessionDetail" class="muted">세션을 선택하면 내용이 표시됩니다.</div>
        </section>

        <section class="card hidden" id="chatSection">
          <h2>대화 로그</h2>
          <div class="grid grid-2" style="margin-top: 16px;">
            <div>
              <h3>AI 피드백</h3>
              <pre id="aiChatLog">세션을 선택하세요.</pre>
            </div>
            <div>
              <h3>동료 피드백</h3>
              <pre id="peerChatLog">세션을 선택하세요.</pre>
            </div>
          </div>
        </section>
      </div>
    </div>

    <script>
      (function(){
        'use strict';

        const APP = window.APP_CONFIG || { apiBaseUrl: '/api', apiKey: '' };
        let authToken = window.localStorage.getItem('writingresearch_admin_token') || '';
        let selectedSessionKey = '';
        let clearOpenAiKey = false;
        let currentSessionDetail = null;
        let rosterStudents = [];

        const sessionCache = new Map();
        const $ = (id) => document.getElementById(id);
        let exportScopeInputs = [];
        const quickMatchState = { primary: '', partner: '' };
        let unmatchedSessionsCache = [];
        let currentPromptContent = '';
        let pendingPairings = [];
        let pairingApplyInProgress = false;
        const selectedSessionKeys = new Set();

        function normalizeBaseUrl(url){
          if (!url) return `${window.location.origin}/api/`;
          const trimmed = String(url).trim();
          if (/^https?:\/\//i.test(trimmed)) {
            return trimmed.endsWith('/') ? trimmed : `${trimmed}/`;
          }
          const prefixed = trimmed.startsWith('/') ? trimmed : `/${trimmed}`;
          const combined = `${window.location.origin}${prefixed}`;
          return combined.endsWith('/') ? combined : `${combined}/`;
        }

        const API_BASE = new URL('admin/', normalizeBaseUrl(APP.apiBaseUrl || '/api')).toString();

        function setStatus(message, type){
          const bar = $('statusBar');
          bar.textContent = message;
          bar.className = `status-bar${type ? ' ' + type : ''}`;
        }

        async function apiRequest(path, { method = 'GET', body, requireAuth = true } = {}) {
          const url = new URL(path, API_BASE).toString();
          const headers = { 'Content-Type': 'application/json' };
          if (requireAuth && authToken) headers['Authorization'] = `Bearer ${authToken}`;
          const response = await fetch(url, {
            method,
            headers,
            body: body ? JSON.stringify(body) : undefined
          });
          if (response.status === 204) return null;
          const text = await response.text();
          let payload = null;
          if (text) {
            try { payload = JSON.parse(text); } catch (err) { throw new Error('서버 응답을 해석하지 못했습니다.'); }
          }
          if (!response.ok) {
            const error = new Error(payload?.error || payload?.message || response.statusText || '요청 실패');
            error.status = response.status;
            throw error;
          }
          return payload;
        }

        function showLogin(){
          $('loginView').classList.remove('hidden');
          $('adminView').classList.add('hidden');
          setStatus('관리자 비밀번호를 입력하세요.', '');
        }

        function showAdmin(){
          $('loginView').classList.add('hidden');
          $('adminView').classList.remove('hidden');
          setStatus('관리자 모드에 접속했습니다.', 'success');
        }

        async function attemptAutoLogin(){
          if (!authToken) return false;
          try {
            await loadConfig();
            await Promise.all([loadPublicSettings(), loadSessions(), loadRoster()]);
            showAdmin();
            return true;
          } catch (error) {
            authToken = '';
            window.localStorage.removeItem('writingresearch_admin_token');
            showLogin();
            return false;
          }
        }

        async function login(){
          const password = $('adminPassword').value.trim();
          if (!password) {
            setStatus('비밀번호를 입력하세요.', 'error');
            return;
          }
          $('btnLogin').disabled = true;
          try {
            const payload = await apiRequest('login', { method: 'POST', body: { password }, requireAuth: false });
            authToken = payload?.token || '';
            if (!authToken) throw new Error('토큰을 수신하지 못했습니다.');
            window.localStorage.setItem('writingresearch_admin_token', authToken);
            $('adminPassword').value = '';
            await loadConfig();
            await Promise.all([loadPublicSettings(), loadSessions(), loadRoster()]);
            showAdmin();
          } catch (error) {
            setStatus(error.message || '로그인에 실패했습니다.', 'error');
          } finally {
            $('btnLogin').disabled = false;
          }
        }

        async function logout(){
          try {
            await apiRequest('logout', { method: 'POST' });
          } catch (error) {
            console.warn(error);
          }
          authToken = '';
          window.localStorage.removeItem('writingresearch_admin_token');
          $('adminPassword').value = '';
          sessionCache.clear();
          currentSessionDetail = null;
          $('sessionTable').querySelector('tbody').innerHTML = '';
          resetDetailPanels();
          clearOpenAiKey = false;
          showLogin();
        }

        async function loadConfig(){
          const data = await apiRequest('config');
          const ai = data?.ai || {};
          const overrides = data?.overrides || {};
          $('aiProvider').value = overrides.provider || 'auto';
          $('aiTemperature').value = overrides.temperature ?? '';
          $('aiSystemPrompt').value = overrides.systemPrompt || '';
          $('openaiModel').value = overrides.openai?.model || ai.openai?.model || '';
          $('openaiBaseUrl').value = overrides.openai?.baseUrl || ai.openai?.baseUrl || '';
          $('openaiOrg').value = overrides.openai?.organization || ai.openai?.organization || '';
          $('openaiApiKey').value = '';
          clearOpenAiKey = false;

          const badge = document.createElement('span');
          let badgeClass = 'disabled';
          let badgeLabel = 'AI 비활성화';
          if (ai.provider === 'openai') {
            badgeClass = 'openai';
            badgeLabel = 'OpenAI 사용 중';
          } else if (ai.provider && ai.provider !== 'none') {
            badgeClass = 'openai';
            badgeLabel = `${ai.provider} 사용 중`;
          }
          badge.className = `badge ${badgeClass}`;
          badge.textContent = badgeLabel;
          const statusContainer = document.createElement('div');
          statusContainer.className = 'ai-status';
          statusContainer.appendChild(badge);
          const configSection = $('adminView').querySelector('section.card');
          const previousStatus = configSection.querySelector('.ai-status');
          if (previousStatus) previousStatus.remove();
          configSection.insertBefore(statusContainer, configSection.children[1]);
        }

        async function saveConfig(){
          const provider = $('aiProvider').value;
          const temperatureValue = $('aiTemperature').value;
          const systemPrompt = $('aiSystemPrompt').value;
          const payload = {
            provider,
            temperature: temperatureValue === '' ? null : Number(temperatureValue),
            systemPrompt,
            openai: {
              model: $('openaiModel').value,
              baseUrl: $('openaiBaseUrl').value,
              organization: $('openaiOrg').value
            }
          };

          const apiKeyInput = $('openaiApiKey').value;
          if (clearOpenAiKey) {
            payload.openai.apiKey = null;
          } else if (apiKeyInput && apiKeyInput.trim()) {
            payload.openai.apiKey = apiKeyInput.trim();
          }

          $('btnSaveConfig').disabled = true;
          try {
            await apiRequest('config', { method: 'POST', body: payload });
            $('openaiApiKey').value = '';
            clearOpenAiKey = false;
            setStatus('AI 설정이 저장되었습니다.', 'success');
            await loadConfig();
          } catch (error) {
            setStatus(error.message || '설정 저장에 실패했습니다.', 'error');
          } finally {
            $('btnSaveConfig').disabled = false;
          }
        }

        async function loadSessions(options = {}){
          const { skipAutoPairing = false } = options;
          const data = await apiRequest('sessions');
          const list = data?.sessions || [];
          const tbody = $('sessionTable').querySelector('tbody');
          const optionList = $('sessionOptions');
          tbody.innerHTML = '';
          optionList.innerHTML = '';
          const availableKeys = new Set(list.map((item) => item.sessionKey));
          Array.from(selectedSessionKeys).forEach((key) => {
            if (!availableKeys.has(key)) {
              selectedSessionKeys.delete(key);
            }
          });
          sessionCache.clear();
          unmatchedSessionsCache = [];

          if (!list.length) {
            resetDetailPanels();
            const row = document.createElement('tr');
            const cell = document.createElement('td');
            cell.colSpan = 7;
            cell.className = 'muted';
            cell.textContent = '등록된 세션이 없습니다.';
            row.appendChild(cell);
            tbody.appendChild(row);
            renderUnmatchedSessions();
            renderQuickMatchDetails();
            updateSessionActionButtons();
            syncSessionSelectAllState();
            return;
          }

          list.sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
          unmatchedSessionsCache = list.filter((item) => {
            if (!item.partner) return true;
            const partner = item.partner || {};
            return !partner.sessionKey && !partner.id;
          });
          renderUnmatchedSessions();

          list.forEach((item) => {
            sessionCache.set(item.sessionKey, item);
            const option = document.createElement('option');
            option.value = item.sessionKey;
            const studentLabel = `${item.user?.name || ''} ${item.user?.id ? `(${item.user.id})` : ''}`.trim();
            option.label = `${item.sessionKey} · ${studentLabel || '학생 정보 없음'}`;
            optionList.appendChild(option);

            const row = document.createElement('tr');
            row.dataset.sessionKey = item.sessionKey;
            if (item.sessionKey === selectedSessionKey) row.classList.add('active');
            const stageLabel = `단계 ${item.stage || 1}`;
            const updated = item.updatedAt ? formatDateTime(item.updatedAt) : '-';
            const partnerLabel = formatPartnerCell(item.partner);
            row.innerHTML = `
              <td>
                <input type="checkbox" class="session-select" data-session-key="${item.sessionKey}" />
              </td>
              <td>${item.sessionKey}</td>
              <td>${item.group || '-'}</td>
              <td>${escapeHtml(item.user?.name || '')} ${item.user?.id ? `(${escapeHtml(item.user.id)})` : ''}</td>
              <td>${stageLabel}</td>
              <td>${partnerLabel}</td>
              <td>${updated}</td>
            `;
            row.addEventListener('click', (event) => {
              if (event.target && event.target.closest('.session-select')) return;
              selectSession(item.sessionKey);
            });
            tbody.appendChild(row);
            const checkbox = row.querySelector('.session-select');
            if (checkbox) {
              checkbox.checked = selectedSessionKeys.has(item.sessionKey);
              checkbox.addEventListener('click', (event) => event.stopPropagation());
              checkbox.addEventListener('change', (event) => handleSessionCheckboxChange(item.sessionKey, event.target.checked));
            }
          });
          renderQuickMatchDetails();
          if (selectedSessionKey && !sessionCache.has(selectedSessionKey)) {
            selectedSessionKey = '';
            resetDetailPanels();
          }
          updateSessionActionButtons();
          syncSessionSelectAllState();
          if (!skipAutoPairing && pendingPairings.length && !pairingApplyInProgress) {
            const snapshot = pendingPairings.slice();
            const { pending: remaining, applied } = await applyPairingsFromCsv(snapshot, {
              showStatus: false,
              refreshSessions: false
            });
            setPendingPairings(remaining);
            if (applied) {
              await loadSessions({ skipAutoPairing: true });
              if (!remaining.length) {
                setStatus('대기 중이던 동료 매칭을 자동으로 완료했습니다.', 'success');
              } else {
                setStatus(`동료 매칭 ${applied}쌍을 자동으로 완료했고 남은 대기 ${remaining.length}쌍이 있습니다.`, 'warn');
              }
              return;
            } else if (remaining.length < snapshot.length) {
              if (!remaining.length) {
                setStatus('대기 중이던 동료 매칭이 모두 이미 연결되어 있습니다.', '');
              } else {
                setStatus(`동료 매칭 자동 확인 결과, 남은 대기 ${remaining.length}쌍이 있습니다.`, 'warn');
              }
            }
          }
        }

        async function selectSession(sessionKey){
          selectedSessionKey = sessionKey;
          const rows = $('sessionTable').querySelectorAll('tbody tr');
          rows.forEach((row) => {
            row.classList.toggle('active', row.dataset.sessionKey === sessionKey);
          });
          setStatus(`세션 ${sessionKey} 상세 정보를 불러오는 중입니다.`, '');
          try {
            const [{ session }, aiChats, peerChats] = await Promise.all([
              apiRequest(`sessions/${sessionKey}`),
              apiRequest(`sessions/${sessionKey}/chats/ai`),
              apiRequest(`sessions/${sessionKey}/chats/peer`)
            ]);
            currentSessionDetail = session;
            sessionCache.set(session.sessionKey, {
              ...(sessionCache.get(session.sessionKey) || {}),
              partner: session.partner,
              user: session.you,
              group: session.mode,
              stage: session.stage,
              updatedAt: session.updatedAt
            });
            showDetailPanels();
            renderSessionDetail(session);
            populatePartnerForm(session);
            renderQuickMatchDetails();
            renderChatLogs(aiChats?.messages || [], peerChats?.messages || []);
            setStatus(`세션 ${sessionKey} 상세 정보를 불러왔습니다.`, 'success');
          } catch (error) {
            setStatus(error.message || '세션 정보를 불러오지 못했습니다.', 'error');
          }
        }

        function renderSessionDetail(session){
          const container = $('sessionDetail');
          if (!session) {
            container.textContent = '세션 데이터를 찾을 수 없습니다.';
            return;
          }
          const updatedAt = session.updatedAt ? formatDateTime(session.updatedAt) : '정보 없음';
          const createdAt = session.createdAt ? formatDateTime(session.createdAt) : '정보 없음';
          const studentName = escapeHtml(session.you?.name || '이름 없음');
          const studentId = escapeHtml(session.you?.id || '-');
          const partnerInfo = session.partner ? formatPartnerDetail(session.partner) : '';

          const stageBlocks = buildStageBlocks(session).join('');

          container.innerHTML = `
            <div class="detail-heading">
              <div class="detail-id">
                <strong>${studentName}</strong>
                <span class="badge group">${escapeHtml(session.mode || '-')} 집단</span>
                <span class="badge stage">단계 ${session.stage || 1}</span>
              </div>
              <div class="muted">최근 업데이트 · ${updatedAt}</div>
            </div>
            <div class="detail-info-grid">
              <div><span class="detail-label">세션 키</span><p>${escapeHtml(session.sessionKey)}</p></div>
              <div><span class="detail-label">식별 번호</span><p>${studentId}</p></div>
              <div><span class="detail-label">생성 시간</span><p>${createdAt}</p></div>
              <div><span class="detail-label">AI 세션</span><p>${escapeHtml(session.aiSessionId || '-')}</p></div>
            </div>
            ${partnerInfo}
            <div class="stage-list">
              ${stageBlocks}
            </div>
          `;
        }

        function renderChatLogs(aiMessages, peerMessages){
          const format = (list) => {
            if (!list.length) return '대화 기록이 없습니다.';
            return list
              .map((msg) => {
                const time = msg.ts ? formatDateTime(msg.ts) : '';
                const name = msg.senderName || msg.role || '사용자';
                return `[${time}] ${name}:\n${msg.text || ''}`;
              })
              .join('\n\n');
          };
          $('aiChatLog').textContent = format(aiMessages);
          $('peerChatLog').textContent = format(peerMessages);
        }

        $('btnLogin').addEventListener('click', login);
        $('btnClearStored').addEventListener('click', () => {
          window.localStorage.removeItem('writingresearch_admin_token');
          authToken = '';
          setStatus('저장된 토큰을 삭제했습니다.', 'success');
        });
        $('btnLogout').addEventListener('click', logout);
        $('btnReloadSessions').addEventListener('click', async () => {
          try {
            await loadSessions();
            setStatus('세션 목록을 새로고침했습니다.', 'success');
          } catch (error) {
            setStatus(error.message || '세션 목록을 불러오지 못했습니다.', 'error');
          }
        });
        $('btnReloadConfig').addEventListener('click', async () => {
          try {
            await loadConfig();
            setStatus('AI 설정을 새로고침했습니다.', 'success');
          } catch (error) {
            setStatus(error.message || 'AI 설정을 불러오지 못했습니다.', 'error');
          }
        });
        $('btnDownloadExport').addEventListener('click', downloadExport);
        $('btnSelectSession').addEventListener('click', handleSessionSearchSubmit);
        $('sessionSearchInput').addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            handleSessionSearchSubmit();
          }
        });
        $('sessionSearchInput').addEventListener('change', () => {
          const resolved = resolveSessionSearchValue($('sessionSearchInput').value);
          if (resolved && sessionCache.has(resolved)) {
            selectSession(resolved);
            $('sessionSearchInput').value = resolved;
          }
        });
        $('btnDeleteSelectedSession').addEventListener('click', deleteSelectedSessions);
        $('btnDeleteAllSessions').addEventListener('click', deleteAllSessions);
        $('btnDeleteUnmatchedSessions').addEventListener('click', deleteUnmatchedSessions);
        $('sessionSelectAll').addEventListener('change', (event) => handleSessionSelectAllChange(event.target.checked));
        exportScopeInputs = Array.from(document.querySelectorAll('[data-export-scope]'));
        exportScopeInputs.forEach((input) => input.addEventListener('change', handleExportScopeChange));
        $('btnQuickMatchApply').addEventListener('click', handleQuickMatchApply);
        $('btnQuickMatchSwap').addEventListener('click', handleQuickMatchSwap);
        $('btnQuickMatchClear').addEventListener('click', handleQuickMatchClear);
        $('quickMatchPrimary').addEventListener('change', () => resolveQuickMatchInput('primary', false));
        $('quickMatchPartner').addEventListener('change', () => resolveQuickMatchInput('partner', false));
        $('quickMatchPrimary').addEventListener('blur', () => resolveQuickMatchInput('primary', true));
        $('quickMatchPartner').addEventListener('blur', () => resolveQuickMatchInput('partner', true));
        $('quickMatchUnmatchedList').addEventListener('click', handleQuickMatchUnmatchedClick);
        $('promptTextarea').addEventListener('input', () => {
          renderPromptPreview($('promptTextarea').value);
          updatePromptSaveButton();
        });
        $('btnPromptSave').addEventListener('click', savePrompt);
        $('btnPromptReload').addEventListener('click', () => loadPublicSettings(true));
        $('btnRosterDownloadTemplate').addEventListener('click', downloadRosterTemplate);
        $('rosterFileInput').addEventListener('change', handleRosterFileInput);
        $('btnApplyCsvPairings').addEventListener('click', async () => {
          if (!pendingPairings.length) return;
          const { pending: remaining, applied } = await applyPairingsFromCsv(pendingPairings);
          setPendingPairings(remaining);
          if (remaining.length) {
            const ids = remaining.map((pair) => `${pair.primary.id}↔${pair.partner.id}`).join(', ');
            setStatus(`아직 매칭되지 않은 쌍이 있습니다: ${ids}`, 'warn');
          } else if (!applied) {
            setStatus('적용할 동료 매칭이 없습니다.', '');
          }
        });
        $('btnRosterClear').addEventListener('click', clearRoster);
        $('btnSaveConfig').addEventListener('click', saveConfig);
        $('btnClearOpenAiKey').addEventListener('click', () => {
          clearOpenAiKey = true;
          $('openaiApiKey').value = '';
          setStatus('OpenAI 키를 삭제하도록 설정했습니다. 저장을 눌러 반영하세요.', '');
        });

        $('btnParseBulk').addEventListener('click', () => parseBulkPartnerInput(false));
        $('partnerBulkInput').addEventListener('input', () => parseBulkPartnerInput(true));
        $('btnAssignPartner').addEventListener('click', assignPartner);
        $('btnClearPartner').addEventListener('click', clearPartner);
        $('btnJumpPartner').addEventListener('click', jumpToPartner);
        $('btnRosterSave').addEventListener('click', saveRoster);
        $('btnRosterReload').addEventListener('click', loadRoster);
        $('rosterTextarea').addEventListener('input', handleRosterInput);

        updateSessionActionButtons();
        attemptAutoLogin();
        function resetDetailPanels(){
          $('sessionDetailSection').classList.add('hidden');
          $('chatSection').classList.add('hidden');
          $('partnerSection').classList.add('hidden');
          $('sessionDetail').textContent = '세션을 선택하면 내용이 표시됩니다.';
          $('aiChatLog').textContent = '세션을 선택하세요.';
          $('peerChatLog').textContent = '세션을 선택하세요.';
          setParsedPartnerValues('', '', '');
          $('btnClearPartner').disabled = true;
          updateSessionActionButtons();
        }

        function showDetailPanels(){
          $('sessionDetailSection').classList.remove('hidden');
          $('chatSection').classList.remove('hidden');
          $('partnerSection').classList.remove('hidden');
        }

        function ensureQuickMatchSelection(field){
          const key = quickMatchState[field];
          if (key && !sessionCache.has(key)) {
            quickMatchState[field] = '';
            const inputId = field === 'primary' ? 'quickMatchPrimary' : 'quickMatchPartner';
            const input = $(inputId);
            if (input) input.value = '';
          }
        }

        function buildQuickMatchSummaryMarkup(sessionKey){
          if (!sessionKey) return '<span class="muted">세션을 선택하세요.</span>';
          const session = sessionCache.get(sessionKey);
          if (!session) return '<span class="muted">세션 정보를 찾을 수 없습니다. 세션 목록을 새로고침하세요.</span>';
          const name = escapeHtml(session.user?.name || '이름 없음');
          const id = session.user?.id ? ` (${escapeHtml(session.user.id)})` : '';
          const group = escapeHtml(session.group || session.mode || '-');
          const stageLabel = session.stage ? `단계 ${session.stage}` : '단계 정보 없음';
          const partnerLabel = session.partner
            ? escapeHtml(session.partner.name || session.partner.sessionKey || session.partner.id || '지정됨')
            : '미지정';
          const updated = session.updatedAt ? formatDateTime(session.updatedAt) : '정보 없음';
          return `
            <strong>${name}${id}</strong>
            <div class="muted">집단 ${group} · ${stageLabel}</div>
            <div class="muted">동료: ${partnerLabel}</div>
            <div class="muted">최근 업데이트 · ${updated}</div>
          `;
        }

        function renderUnmatchedSessions(list = unmatchedSessionsCache){
          const container = $('quickMatchUnmatchedList');
          if (!container) return;
          container.innerHTML = '';
          if (!Array.isArray(list) || !list.length) {
            const empty = document.createElement('div');
            empty.className = 'muted';
            empty.textContent = '모든 세션이 매칭되었습니다.';
            container.appendChild(empty);
            return;
          }
          list.forEach((item) => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'unmatched-chip';
            if (item.sessionKey === quickMatchState.primary || item.sessionKey === quickMatchState.partner) {
              button.classList.add('selected');
            }
            button.dataset.sessionKey = item.sessionKey;
            const studentLabel = `${item.user?.name || ''}${item.user?.id ? ` (${item.user.id})` : ''}`.trim();
            button.textContent = studentLabel ? `${item.sessionKey} · ${studentLabel}` : item.sessionKey;
            container.appendChild(button);
          });
        }

        function renderQuickMatchDetails(){
          ensureQuickMatchSelection('primary');
          ensureQuickMatchSelection('partner');
          const primarySummary = $('quickMatchPrimarySummary');
          const partnerSummary = $('quickMatchPartnerSummary');
          if (primarySummary) primarySummary.innerHTML = buildQuickMatchSummaryMarkup(quickMatchState.primary);
          if (partnerSummary) partnerSummary.innerHTML = buildQuickMatchSummaryMarkup(quickMatchState.partner);
          const applyButton = $('btnQuickMatchApply');
          if (applyButton) {
            applyButton.disabled = !(quickMatchState.primary && quickMatchState.partner && quickMatchState.primary !== quickMatchState.partner);
          }
          renderUnmatchedSessions();
          updateSessionActionButtons();
        }

        function updateCsvPairingButton(){
          const btn = $('btnApplyCsvPairings');
          if (!btn) return;
          btn.disabled = !(pendingPairings && pendingPairings.length);
        }

        function updateSessionActionButtons(){
          const deleteSelectedBtn = $('btnDeleteSelectedSession');
          if (deleteSelectedBtn) deleteSelectedBtn.disabled = selectedSessionKeys.size === 0;
          const deleteUnmatchedBtn = $('btnDeleteUnmatchedSessions');
          if (deleteUnmatchedBtn) deleteUnmatchedBtn.disabled = !(unmatchedSessionsCache && unmatchedSessionsCache.length);
          const deleteAllBtn = $('btnDeleteAllSessions');
          if (deleteAllBtn) deleteAllBtn.disabled = sessionCache.size === 0;
          updateCsvPairingButton();
        }

        function syncSessionSelectAllState(){
          const headerCheckbox = $('sessionSelectAll');
          if (!headerCheckbox) return;
          const checkboxes = $('sessionTable').querySelectorAll('tbody .session-select');
          const total = checkboxes.length;
          const selectedCount = selectedSessionKeys.size;
          headerCheckbox.disabled = total === 0;
          if (total === 0) {
            headerCheckbox.checked = false;
            headerCheckbox.indeterminate = false;
            return;
          }
          headerCheckbox.checked = selectedCount === total;
          headerCheckbox.indeterminate = selectedCount > 0 && selectedCount < total;
        }

        function handleSessionCheckboxChange(sessionKey, checked){
          if (!sessionKey) return;
          if (checked) {
            selectedSessionKeys.add(sessionKey);
          } else {
            selectedSessionKeys.delete(sessionKey);
          }
          syncSessionSelectAllState();
          updateSessionActionButtons();
        }

        function handleSessionSelectAllChange(checked){
          if (checked) {
            sessionCache.forEach((_, key) => selectedSessionKeys.add(key));
          } else {
            selectedSessionKeys.clear();
          }
          const checkboxes = $('sessionTable').querySelectorAll('tbody .session-select');
          checkboxes.forEach((checkbox) => {
            checkbox.checked = checked;
          });
          syncSessionSelectAllState();
          updateSessionActionButtons();
        }

        function setPendingPairings(list){
          pendingPairings = Array.isArray(list) ? list.filter((pair) => pair && pair.primary && pair.partner) : [];
          updateSessionActionButtons();
        }

        function findSessionByStudentId(studentId){
          const target = String(studentId || '').trim().toLowerCase();
          if (!target) return null;
          for (const session of sessionCache.values()) {
            const id = String(session?.user?.id || '').trim().toLowerCase();
            if (id && id === target) return session;
          }
          return null;
        }

        function renderPromptPreview(content){
          const preview = $('promptPreview');
          if (!preview) return;
          const trimmed = String(content || '').trim();
          if (!trimmed) {
            preview.classList.add('empty');
            preview.innerHTML = '제시문이 아직 등록되지 않았습니다.';
            return;
          }
          preview.classList.remove('empty');
          const escaped = escapeHtml(trimmed).replace(/\n/g, '<br/>');
          preview.innerHTML = escaped;
        }

        function updatePromptSaveButton(){
          const textarea = $('promptTextarea');
          const button = $('btnPromptSave');
          if (!textarea || !button) return;
          const current = String(currentPromptContent || '');
          const incoming = String(textarea.value || '');
          button.disabled = current.trim() === incoming.trim();
        }

        async function loadPublicSettings(showStatus = false){
          try {
            const settings = await apiRequest('public-settings');
            currentPromptContent = settings?.promptContent || '';
            const textarea = $('promptTextarea');
            if (textarea) {
              textarea.value = currentPromptContent;
            }
            renderPromptPreview(currentPromptContent);
            updatePromptSaveButton();
            if (showStatus) {
              setStatus('제시문을 불러왔습니다.', 'success');
            }
            return settings;
          } catch (error) {
            setStatus(error.message || '제시문을 불러오지 못했습니다.', 'error');
            throw error;
          }
        }

        async function savePrompt(){
          const textarea = $('promptTextarea');
          if (!textarea) return;
          const button = $('btnPromptSave');
          const value = textarea.value;
          if (button) button.disabled = true;
          try {
            const response = await apiRequest('public-settings', { method: 'POST', body: { promptContent: value } });
            currentPromptContent = response?.promptContent || String(value || '').trim();
            textarea.value = currentPromptContent;
            renderPromptPreview(currentPromptContent);
            updatePromptSaveButton();
            setStatus('제시문을 저장했습니다.', 'success');
          } catch (error) {
            setStatus(error.message || '제시문을 저장하지 못했습니다.', 'error');
          } finally {
            updatePromptSaveButton();
          }
        }

        function setQuickMatchField(field, sessionKey){
          const key = String(sessionKey || '').trim();
          const inputId = field === 'primary' ? 'quickMatchPrimary' : 'quickMatchPartner';
          const input = $(inputId);
          if (!input) return;
          if (key && !sessionCache.has(key)) {
            setStatus('세션 목록에서 선택한 키를 찾을 수 없습니다.', 'error');
            return;
          }
          quickMatchState[field] = key;
          if (input.value !== key) input.value = key;
          renderQuickMatchDetails();
        }

        function resolveQuickMatchInput(field, showError){
          const inputId = field === 'primary' ? 'quickMatchPrimary' : 'quickMatchPartner';
          const input = $(inputId);
          if (!input) return;
          const raw = input.value;
          if (!raw.trim()) {
            setQuickMatchField(field, '');
            return;
          }
          const resolved = resolveSessionSearchValue(raw);
          if (resolved) {
            setQuickMatchField(field, resolved);
            input.value = resolved;
          } else if (showError) {
            setStatus('세션을 찾지 못했습니다. 정확한 세션 키 또는 학생 정보를 입력하세요.', 'error');
            setQuickMatchField(field, '');
            input.value = '';
          }
        }

        async function handleQuickMatchApply(){
          const primary = quickMatchState.primary;
          const partner = quickMatchState.partner;
          if (!primary || !partner) {
            setStatus('두 학생의 세션을 모두 선택하세요.', 'error');
            return;
          }
          if (primary === partner) {
            setStatus('서로 다른 세션을 선택하세요.', 'error');
            return;
          }
          const button = $('btnQuickMatchApply');
          if (button) button.disabled = true;
          try {
            setStatus('동료 매칭을 저장하는 중입니다...', '');
            await Promise.all([
              apiRequest(`sessions/${primary}/partner`, { method: 'POST', body: { partnerSessionKey: partner } }),
              apiRequest(`sessions/${partner}/partner`, { method: 'POST', body: { partnerSessionKey: primary } })
            ]);
            await loadSessions();
            setStatus('두 학생을 서로 동료로 매칭했습니다.', 'success');
            setQuickMatchField('primary', primary);
            setQuickMatchField('partner', partner);
            await selectSession(primary);
          } catch (error) {
            setStatus(error.message || '동료 매칭에 실패했습니다.', 'error');
          } finally {
            if (button) {
              button.disabled = !(quickMatchState.primary && quickMatchState.partner && quickMatchState.primary !== quickMatchState.partner);
            }
          }
        }

        function handleQuickMatchSwap(){
          const { primary, partner } = quickMatchState;
          quickMatchState.primary = partner || '';
          quickMatchState.partner = primary || '';
          const primaryInput = $('quickMatchPrimary');
          const partnerInput = $('quickMatchPartner');
          if (primaryInput) primaryInput.value = quickMatchState.primary;
          if (partnerInput) partnerInput.value = quickMatchState.partner;
          renderQuickMatchDetails();
        }

        function handleQuickMatchClear(){
          quickMatchState.primary = '';
          quickMatchState.partner = '';
          const primaryInput = $('quickMatchPrimary');
          const partnerInput = $('quickMatchPartner');
          if (primaryInput) primaryInput.value = '';
          if (partnerInput) partnerInput.value = '';
          renderQuickMatchDetails();
        }

        function handleQuickMatchUnmatchedClick(event){
          const target = event.target.closest('[data-session-key]');
          if (!target) return;
          const key = target.dataset.sessionKey;
          if (!key || !sessionCache.has(key)) return;
          if (quickMatchState.primary === key) {
            setQuickMatchField('primary', '');
            return;
          }
          if (quickMatchState.partner === key) {
            setQuickMatchField('partner', '');
            return;
          }
          if (!quickMatchState.primary) {
            setQuickMatchField('primary', key);
            return;
          }
          if (!quickMatchState.partner) {
            setQuickMatchField('partner', key);
            return;
          }
          setQuickMatchField('primary', key);
          setQuickMatchField('partner', '');
        }

        async function applyPairingsFromCsv(pairings, { showStatus = true, refreshSessions = true } = {}){
          if (!Array.isArray(pairings) || !pairings.length) {
            return { pending: [], applied: 0 };
          }
          if (pairingApplyInProgress) {
            return { pending: pairings, applied: 0 };
          }
          pairingApplyInProgress = true;
          try {
            if (refreshSessions) {
              await loadSessions({ skipAutoPairing: true });
            }
            const pending = [];
            let applied = 0;
            for (const pair of pairings) {
              const primaryId = String(pair?.primary?.id || '').trim();
              const partnerId = String(pair?.partner?.id || '').trim();
              if (!primaryId || !partnerId) {
                pending.push(pair);
                continue;
              }
              const sessionA = findSessionByStudentId(primaryId);
              const sessionB = findSessionByStudentId(partnerId);
              if (!sessionA || !sessionB) {
                pending.push(pair);
                continue;
              }
              if (sessionA.partner?.sessionKey === sessionB.sessionKey && sessionB.partner?.sessionKey === sessionA.sessionKey) {
                continue;
              }
              try {
                await Promise.all([
                  apiRequest(`sessions/${sessionA.sessionKey}/partner`, { method: 'POST', body: { partnerSessionKey: sessionB.sessionKey } }),
                  apiRequest(`sessions/${sessionB.sessionKey}/partner`, { method: 'POST', body: { partnerSessionKey: sessionA.sessionKey } })
                ]);
                applied += 1;
              } catch (error) {
                console.warn('Failed to apply pairing', pair, error);
                pending.push(pair);
              }
            }
            if (applied && refreshSessions) {
              await loadSessions({ skipAutoPairing: true });
            }
            if (showStatus) {
              if (applied && !pending.length) {
                setStatus(`CSV에서 ${applied}쌍의 동료 매칭을 적용했습니다.`, 'success');
              } else if (!applied && !pending.length) {
                setStatus('적용할 동료 매칭이 없습니다.', '');
              } else {
                setStatus(`동료 매칭 적용 완료: ${applied}쌍, 대기: ${pending.length}쌍`, pending.length ? 'warn' : 'success');
              }
            }
            return { pending, applied };
          } finally {
            pairingApplyInProgress = false;
          }
        }

        async function deleteSelectedSessions(){
          const keys = Array.from(selectedSessionKeys);
          if (!keys.length) {
            setStatus('삭제할 세션을 선택하세요.', 'error');
            return;
          }
          if (!confirm(`선택한 세션 ${keys.length}개를 삭제하시겠습니까?`)) return;
          const button = $('btnDeleteSelectedSession');
          if (button) button.disabled = true;
          try {
            const response = await apiRequest('sessions/bulk-delete', { method: 'POST', body: { sessionKeys: keys } });
            const deletedList = Array.isArray(response?.deleted) ? response.deleted : [];
            const errorList = Array.isArray(response?.errors) ? response.errors : [];
            deletedList.forEach((key) => {
              selectedSessionKeys.delete(key);
              if (quickMatchState.primary === key) setQuickMatchField('primary', '');
              if (quickMatchState.partner === key) setQuickMatchField('partner', '');
              if (selectedSessionKey === key) {
                selectedSessionKey = '';
                resetDetailPanels();
              }
            });
            let message = deletedList.length ? `세션 ${deletedList.length}개를 삭제했습니다.` : '삭제된 세션이 없습니다.';
            if (errorList.length) {
              const failed = errorList.map((item) => item.sessionKey).join(', ');
              message += ` 실패 ${errorList.length}개: ${failed}`;
              setStatus(message, 'warn');
            } else {
              setStatus(message, 'success');
            }
            await loadSessions();
          } catch (error) {
            setStatus(error.message || '세션을 삭제하지 못했습니다.', 'error');
          } finally {
            if (button) button.disabled = false;
            syncSessionSelectAllState();
            updateSessionActionButtons();
          }
        }

        async function deleteUnmatchedSessions(){
          const list = Array.isArray(unmatchedSessionsCache) ? unmatchedSessionsCache : [];
          if (!list.length) {
            setStatus('삭제할 미매칭 세션이 없습니다.', '');
            return;
          }
          if (!confirm(`미매칭 세션 ${list.length}개를 삭제하시겠습니까?`)) return;
          const button = $('btnDeleteUnmatchedSessions');
          if (button) button.disabled = true;
          const sessionKeys = list.map((item) => item.sessionKey);
          try {
            const response = await apiRequest('sessions/bulk-delete', { method: 'POST', body: { sessionKeys } });
            const deletedList = Array.isArray(response?.deleted) ? response.deleted : [];
            const errors = Array.isArray(response?.errors) ? response.errors : [];
            deletedList.forEach((key) => {
              selectedSessionKeys.delete(key);
              if (quickMatchState.primary === key) setQuickMatchField('primary', '');
              if (quickMatchState.partner === key) setQuickMatchField('partner', '');
              if (selectedSessionKey === key) {
                selectedSessionKey = '';
                resetDetailPanels();
              }
            });
            let message = deletedList.length ? `세션 ${deletedList.length}개를 삭제했습니다.` : '삭제된 세션이 없습니다.';
            if (errors.length) {
              const failed = errors.map((item) => item.sessionKey).join(', ');
              message += ` 실패 ${errors.length}개: ${failed}`;
              setStatus(message, 'warn');
            } else {
              setStatus(message, 'success');
            }
            await loadSessions();
          } catch (error) {
            setStatus(error.message || '세션을 삭제하지 못했습니다.', 'error');
          } finally {
            if (button) button.disabled = false;
            syncSessionSelectAllState();
            updateSessionActionButtons();
          }
        }

        async function deleteAllSessions(){
          const allKeys = Array.from(sessionCache.keys());
          if (!allKeys.length) {
            setStatus('삭제할 세션이 없습니다.', '');
            return;
          }
          if (!confirm(`총 ${allKeys.length}개의 세션을 모두 삭제하시겠습니까?`)) return;
          const button = $('btnDeleteAllSessions');
          if (button) button.disabled = true;
          try {
            const response = await apiRequest('sessions/bulk-delete', { method: 'POST', body: { sessionKeys: allKeys } });
            const deletedList = Array.isArray(response?.deleted) ? response.deleted : [];
            const errors = Array.isArray(response?.errors) ? response.errors : [];
            deletedList.forEach((key) => {
              selectedSessionKeys.delete(key);
              if (quickMatchState.primary === key) setQuickMatchField('primary', '');
              if (quickMatchState.partner === key) setQuickMatchField('partner', '');
              if (selectedSessionKey === key) {
                selectedSessionKey = '';
                resetDetailPanels();
              }
            });
            let message = deletedList.length ? `세션 ${deletedList.length}개를 삭제했습니다.` : '삭제된 세션이 없습니다.';
            if (errors.length) {
              const failed = errors.map((item) => item.sessionKey).join(', ');
              message += ` 실패 ${errors.length}개: ${failed}`;
              setStatus(message, 'warn');
            } else {
              setStatus(message, 'success');
            }
            await loadSessions();
          } catch (error) {
            setStatus(error.message || '세션 전체 삭제에 실패했습니다.', 'error');
          } finally {
            if (button) button.disabled = false;
            syncSessionSelectAllState();
            updateSessionActionButtons();
          }
        }

        function handleSessionSearchSubmit(){
          const input = $('sessionSearchInput');
          if (!input) return;
          const resolvedKey = resolveSessionSearchValue(input.value);
          if (!resolvedKey) {
            setStatus('일치하는 세션을 찾지 못했습니다.', 'error');
            return;
          }
          if (!sessionCache.has(resolvedKey)) {
            setStatus('세션 데이터를 로드하지 못했습니다.', 'error');
            return;
          }
          input.value = resolvedKey;
          selectSession(resolvedKey);
        }

        function resolveSessionSearchValue(raw){
          const value = String(raw || '').trim();
          if (!value) return '';
          if (sessionCache.has(value)) return value;
          const lower = value.toLowerCase();
          for (const key of sessionCache.keys()) {
            if (key.toLowerCase() === lower) return key;
          }
          for (const [key, session] of sessionCache.entries()) {
            const name = String(session?.user?.name || '').toLowerCase();
            const id = String(session?.user?.id || '').toLowerCase();
            if (name === lower || id === lower) {
              return key;
            }
          }
          for (const [key, session] of sessionCache.entries()) {
            const name = String(session?.user?.name || '').toLowerCase();
            const id = String(session?.user?.id || '').toLowerCase();
            if ((name && name.includes(lower)) || (id && id.includes(lower))) {
              return key;
            }
          }
          return '';
        }

        function handleExportScopeChange(event){
          const input = event?.target;
          if (!input || !input.dataset.exportScope) return;
          if (!exportScopeInputs.length) {
            exportScopeInputs = Array.from(document.querySelectorAll('[data-export-scope]'));
          }
          const allToggle = $('exportScopeAll');
          if (input.value === 'all') {
            const checked = input.checked;
            exportScopeInputs.forEach((item) => {
              if (item.value !== 'all') {
                item.checked = checked;
              }
            });
          } else {
            if (!input.checked && allToggle) {
              allToggle.checked = false;
            } else if (allToggle) {
              const others = exportScopeInputs.filter((item) => item.value !== 'all');
              const everyChecked = others.every((item) => item.checked);
              allToggle.checked = everyChecked;
            }
          }
        }

        function getSelectedExportScopes(){
          if (!exportScopeInputs.length) {
            exportScopeInputs = Array.from(document.querySelectorAll('[data-export-scope]'));
          }
          const values = exportScopeInputs
            .filter((input) => input.checked)
            .map((input) => input.value)
            .filter(Boolean);
          if (!values.length) return [];
          const unique = Array.from(new Set(values));
          if (unique.includes('all')) {
            const others = unique.filter((item) => item !== 'all');
            return ['all', ...others];
          }
          return unique;
        }

        function formatPartnerCell(partner){
          if (!partner) return '<span class="muted">-</span>';
          const name = escapeHtml(partner.name || '이름 없음');
          const id = escapeHtml(partner.id || '');
          const sessionKey = escapeHtml(partner.sessionKey || '');
          const parts = [name];
          if (id) parts.push(`(${id})`);
          if (sessionKey) parts.push(`<br/><span class="muted">${sessionKey}</span>`);
          return parts.join(' ');
        }

        function formatPartnerDetail(partner){
          const name = escapeHtml(partner.name || '미지정');
          const id = escapeHtml(partner.id || '-');
          const sessionKey = escapeHtml(partner.sessionKey || '-');
          return `
            <div class="detail-partner-block">
              <div class="detail-partner-header">
                <div>
                  <span class="detail-label">동료 매칭</span>
                  <p style="margin: 4px 0 0; font-weight: 600;">${name}</p>
                </div>
                <span class="muted">세션 키 · ${sessionKey}</span>
              </div>
              <div class="muted">식별 번호 · ${id}</div>
            </div>
          `;
        }

        function buildStageBlocks(session){
          const list = [];
          const stages = [
            {
              title: '1단계 · 사전 글쓰기',
              meta: session.writing?.prewriting?.submittedAt ? `제출 시간 · ${formatDateTime(session.writing.prewriting.submittedAt)}` : '제출되지 않았습니다.',
              text: session.writing?.prewriting?.text,
              empty: '사전 글쓰기가 작성되지 않았습니다.'
            },
            {
              title: '2단계 · 수정 아이디어 메모',
              meta: session.writing?.draft?.savedAt ? `저장 시간 · ${formatDateTime(session.writing.draft.savedAt)}` : '저장된 메모가 없습니다.',
              text: session.writing?.draft?.text,
              empty: '2단계 메모가 작성되지 않았습니다.'
            },
            {
              title: '3단계 · 동료 피드백 메모',
              meta: session.writing?.notes?.updatedAt ? `저장 시간 · ${formatDateTime(session.writing.notes.updatedAt)}` : '작성된 동료 피드백 메모가 없습니다.',
              text: session.writing?.notes?.text,
              empty: '3단계 메모가 작성되지 않았습니다.'
            },
            {
              title: '4단계 · 최종 글',
              meta: session.writing?.final?.submittedAt ? `제출 시간 · ${formatDateTime(session.writing.final.submittedAt)}` : '최종 글이 아직 제출되지 않았습니다.',
              text: session.writing?.final?.text,
              empty: '최종 글이 아직 작성되지 않았습니다.'
            }
          ];

          stages.forEach((stage) => {
            const content = stage.text ? escapeHtml(stage.text) : `<span class="muted">${stage.empty}</span>`;
            list.push(`
              <div class="stage-block">
                <div class="stage-title">${stage.title}</div>
                <div class="stage-meta">${stage.meta}</div>
                <pre>${content}</pre>
              </div>
            `);
          });
          return list;
        }

        function populatePartnerForm(session){
          const assignBtn = $('btnAssignPartner');
          const clearBtn = $('btnClearPartner');
          const jumpBtn = $('btnJumpPartner');
          const bulkInput = $('partnerBulkInput');

          if (!session) {
            assignBtn.disabled = true;
            clearBtn.disabled = true;
            jumpBtn.disabled = true;
            jumpBtn.dataset.sessionKey = '';
            bulkInput.value = '';
            bulkInput.dataset.sessionKey = '';
            bulkInput.dataset.name = '';
            bulkInput.dataset.id = '';
            return;
          }

          const partner = session.partner || null;
          if (partner) {
            const suggestion = [partner.sessionKey || '', partner.name || '', partner.id || '']
              .filter(Boolean)
              .join(', ');
            bulkInput.value = suggestion;
            setParsedPartnerValues(partner.sessionKey || '', partner.name || '', partner.id || '');
          } else {
            bulkInput.value = '';
            setParsedPartnerValues('', '', '');
          }
          clearBtn.disabled = !partner;
          jumpBtn.disabled = !partner?.sessionKey;
          jumpBtn.dataset.sessionKey = partner?.sessionKey || '';
        }

        async function assignPartner(){
          if (!selectedSessionKey) return;
          parseBulkPartnerInput(true);
          const payload = {};
          const sessionValue = $('partnerBulkInput').dataset.sessionKey?.trim() || '';
          const nameValue = $('partnerBulkInput').dataset.name?.trim() || '';
          const idValue = $('partnerBulkInput').dataset.id?.trim() || '';
          if (!sessionValue && !idValue) {
            setStatus('동료 식별번호 또는 세션 키를 입력하세요.', 'error');
            return;
          }
          if (sessionValue) payload.partnerSessionKey = sessionValue;
          if (nameValue) payload.partnerName = nameValue;
          if (idValue) payload.partnerId = idValue;

          $('btnAssignPartner').disabled = true;
          try {
            const response = await apiRequest(`sessions/${selectedSessionKey}/partner`, { method: 'POST', body: payload });
            currentSessionDetail = response.session;
            setStatus('동료 정보를 저장했습니다.', 'success');
            populatePartnerForm(currentSessionDetail);
            renderSessionDetail(currentSessionDetail);
            setParsedPartnerValues(sessionValue, nameValue, idValue);
            await loadSessions();
          } catch (error) {
            setStatus(error.message || '동료 정보를 저장하지 못했습니다.', 'error');
          }
        }

        async function clearPartner(){
          if (!selectedSessionKey) return;
          $('btnClearPartner').disabled = true;
          try {
            const response = await apiRequest(`sessions/${selectedSessionKey}/partner`, { method: 'DELETE' });
            currentSessionDetail = response.session;
            setStatus('동료 연결을 해제했습니다.', 'success');
            populatePartnerForm(currentSessionDetail);
            renderSessionDetail(currentSessionDetail);
            setParsedPartnerValues('', '', '');
            await loadSessions();
          } catch (error) {
            setStatus(error.message || '동료 연결을 해제하지 못했습니다.', 'error');
          }
        }

        function jumpToPartner(){
          const key = $('btnJumpPartner').dataset.sessionKey;
          if (!key) return;
          selectSession(key);
        }

        function parseBulkPartnerInput(silent = false){
          const textarea = $('partnerBulkInput');
          const raw = textarea.value.trim();
          if (!raw) {
            setParsedPartnerValues('', '', '');
            return;
          }
          const firstLine = raw.split(/\r?\n/)[0];
          const normalized = firstLine.replace(/\t/g, ',');
          const pieces = normalized.split(',').map((part) => part.trim());
          const sessionKey = pieces[0] || '';
          const candidate = sessionCache.get(sessionKey);
          const nameValue = pieces[1] || candidate?.user?.name || '';
          let idValue = pieces[2] || candidate?.user?.id || '';
          if (!sessionKey && !idValue) {
            const rosterMatch = findRosterByName(nameValue);
            if (rosterMatch) {
              idValue = rosterMatch.id;
            }
          }
          const rebuilt = [sessionKey, nameValue, idValue].filter(Boolean).join(', ');
          textarea.value = rebuilt;
          setParsedPartnerValues(sessionKey, nameValue, idValue);
          if (!silent) {
            setStatus('입력한 동료 정보를 불러왔습니다.', 'success');
          }
        }

        function formatDateTime(ms){
          if (!ms) return '정보 없음';
          return new Date(ms).toLocaleString('ko-KR');
        }

        function escapeHtml(str){
          return String(str || '')
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
        }

        function setParsedPartnerValues(sessionKey, name, id){
          const textarea = $('partnerBulkInput');
          textarea.dataset.sessionKey = sessionKey || '';
          textarea.dataset.name = name || '';
          textarea.dataset.id = id || '';
          const existing = currentSessionDetail?.partner || {};
          const changed =
            (sessionKey || '') !== (existing.sessionKey || '') ||
            (name || '') !== (existing.name || '') ||
            (id || '') !== (existing.id || '');
          const hasValue = Boolean(sessionKey || name || id);
          $('btnAssignPartner').disabled = !(changed && hasValue);
          $('btnJumpPartner').disabled = !sessionKey;
          $('btnJumpPartner').dataset.sessionKey = sessionKey || '';
        }

        async function downloadExport(){
          if (!authToken) {
            setStatus('로그인 후 이용하세요.', 'error');
            return;
          }
          const scopes = getSelectedExportScopes();
          if (!scopes.length) {
            setStatus('다운로드할 항목을 하나 이상 선택하세요.', 'error');
            return;
          }
          const button = $('btnDownloadExport');
          button.disabled = true;
          try {
            setStatus('선택한 데이터를 준비 중입니다...', '');
            const params = new URLSearchParams();
            params.set('format', 'xlsx');
            params.set('scopes', scopes.join(','));
            const url = new URL(`sessions/export?${params.toString()}`, API_BASE).toString();
            const headers = { Accept: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' };
            if (authToken) headers['Authorization'] = `Bearer ${authToken}`;
            const response = await fetch(url, { headers });
            if (!response.ok) {
              const text = await response.text();
              throw new Error(text || '데이터를 내보내지 못했습니다.');
            }
            const blob = await response.blob();
            const stamp = new Date().toISOString().replace(/[:.]/g, '-');
            const fileName = `writingresearch-export-${stamp}.xlsx`;
            const blobUrl = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = blobUrl;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(blobUrl);
            setStatus('데이터 내보내기가 완료되었습니다.', 'success');
          } catch (error) {
            setStatus(error.message || '데이터 내보내기에 실패했습니다.', 'error');
          } finally {
            button.disabled = false;
          }
        }
        async function loadRoster(){
          try {
            const data = await apiRequest('roster');
            rosterStudents = Array.isArray(data?.students) ? data.students : [];
            renderRoster();
            setStatus('학생 명단을 불러왔습니다.', 'success');
          } catch (error) {
            setStatus(error.message || '학생 명단을 불러오지 못했습니다.', 'error');
          }
        }

        async function saveRoster(){
          const textarea = $('rosterTextarea');
          const students = parseRosterTextarea(textarea.value);
          if (!students.length) {
            setStatus('저장할 학생 정보가 없습니다.', 'error');
            return;
          }
          $('btnRosterSave').disabled = true;
          try {
            const result = await apiRequest('roster', { method: 'POST', body: { students } });
            rosterStudents = Array.isArray(result?.students) ? result.students : [];
            renderRoster();
            setStatus('학생 명단을 저장했습니다.', 'success');
            await loadSessions();
          } catch (error) {
            setStatus(error.message || '학생 명단을 저장하지 못했습니다.', 'error');
          } finally {
            $('btnRosterSave').disabled = false;
          }
        }

        function handleRosterInput(){
          const textarea = $('rosterTextarea');
          const students = parseRosterTextarea(textarea.value);
          updateRosterCount(students.length);
        }

        function parseRosterCsv(text){
          const lines = String(text || '')
            .split(/\r?\n/)
            .map((line) => line.replace(/\t/g, ',').trim())
            .filter(Boolean);
          if (!lines.length) return { students: [], pairings: [] };
          let start = 0;
          const header = lines[0].toLowerCase();
          if (header.includes('student') || header.includes('학번') || header.includes('id')) {
            start = 1;
          }
          const entryMap = new Map();
          const pairings = [];
          const pushEntry = (id, name) => {
            const trimmedId = String(id || '').trim();
            const trimmedName = String(name || '').trim();
            if (!trimmedId && !trimmedName) return;
            const key = trimmedId.toLowerCase();
            if (!key) return;
            if (!entryMap.has(key)) {
              entryMap.set(key, { id: trimmedId, name: trimmedName });
            } else if (trimmedName && !entryMap.get(key).name) {
              entryMap.get(key).name = trimmedName;
            }
          };

          for (let i = start; i < lines.length; i += 1) {
            const parts = lines[i].split(',').map((part) => part.trim());
            const idA = parts[0] || '';
            const nameA = parts[1] || '';
            const idB = parts[2] || '';
            const nameB = parts[3] || '';
            pushEntry(idA, nameA);
            pushEntry(idB, nameB);
            if (idA && idB) {
              pairings.push({
                primary: { id: idA, name: nameA },
                partner: { id: idB, name: nameB }
              });
            }
          }
          return {
            students: Array.from(entryMap.values()),
            pairings
          };
        }

        function summarizeRosterGroups(students){
          const summary = { A: 0, B: 0, C: 0 };
          students.forEach((student) => {
            const prefix = String(student.id || '').trim().charAt(0).toUpperCase();
            if (summary[prefix] !== undefined) summary[prefix] += 1;
          });
          return summary;
        }

        function downloadRosterTemplate(){
          const rows = [
            ['student_id_a', 'name_a', 'student_id_b', 'name_b'],
            ['A1001', '홍길동', 'A1002', '이영수'],
            ['B2001', '김영희', 'B2002', '최민준'],
            ['C3001', '박철수', '', '']
          ];
          const csv = rows.map((row) => row.join(',')).join('\r\n');
          const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
          const stamp = new Date().toISOString().slice(0, 10);
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = `writingresearch-roster-template-${stamp}.csv`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          setStatus('CSV 템플릿을 내려받았습니다.', 'success');
        }

        function handleRosterFileInput(event){
          const input = event.target;
          const file = input.files && input.files[0];
          if (!file) return;
          if (!/csv|text\//i.test(file.type) && !file.name.toLowerCase().endsWith('.csv')) {
            setStatus('CSV 파일을 선택하세요.', 'error');
            input.value = '';
            return;
          }
          const reader = new FileReader();
          reader.onload = async () => {
            try {
              const text = reader.result || '';
              const { students, pairings } = parseRosterCsv(text);
              if (!students.length) {
                setStatus('CSV에서 학생 정보를 찾지 못했습니다.', 'error');
                return;
              }
              const textarea = $('rosterTextarea');
              if (textarea) {
                textarea.value = students.map((item) => [item.id, item.name].filter(Boolean).join(', ')).join('\n');
                handleRosterInput();
              }
              setPendingPairings(pairings);
              const summary = summarizeRosterGroups(students);
              const summaryText = Object.entries(summary)
                .filter(([, count]) => count > 0)
                .map(([group, count]) => `${group}집단 ${count}명`)
                .join(' · ');
              let message = summaryText ? `CSV에서 학생 ${students.length}명을 불러왔습니다. (${summaryText}) 저장을 눌러 반영하세요.` : `CSV에서 학생 ${students.length}명을 불러왔습니다. 저장을 눌러 반영하세요.`;
              let statusType = 'success';
              if (pairings.length) {
                let remaining = [];
                let applied = 0;
                try {
                  const result = await applyPairingsFromCsv(pairings, { showStatus: false });
                  remaining = result.pending;
                  applied = result.applied;
                } catch (error) {
                  console.error(error);
                  remaining = pairings;
                  statusType = 'warn';
                }
                setPendingPairings(remaining);
                if (applied) {
                  message += ` · 동료 매칭 ${applied}쌍 적용`; 
                }
                if (remaining.length) {
                  statusType = 'warn';
                  const list = remaining.map((pair) => `${pair.primary.id}↔${pair.partner.id}`).join(', ');
                  message += ` · 매칭 대기 ${remaining.length}쌍 (${list})`;
                }
              }
              setStatus(message, statusType);
            } catch (error) {
              console.error(error);
              setStatus('CSV 파일을 해석하지 못했습니다.', 'error');
            } finally {
              input.value = '';
            }
          };
          reader.onerror = () => {
            setStatus('CSV 파일을 읽지 못했습니다.', 'error');
            input.value = '';
          };
          reader.readAsText(file, 'utf-8');
        }

        async function clearRoster(){
          if (!confirm('학생 명단과 동료 매칭 정보를 모두 삭제하시겠습니까?')) return;
          const button = $('btnRosterClear');
          if (button) button.disabled = true;
          try {
            await apiRequest('roster', { method: 'POST', body: { students: [] } });
            rosterStudents = [];
            const textarea = $('rosterTextarea');
            if (textarea) textarea.value = '';
            updateRosterCount(0);
            setPendingPairings([]);
            setStatus('학생 명단을 모두 삭제했습니다.', 'success');
            await loadSessions();
          } catch (error) {
            setStatus(error.message || '학생 명단을 비우지 못했습니다.', 'error');
          } finally {
            if (button) button.disabled = false;
          }
        }

        function parseRosterTextarea(text){
          return String(text || '')
            .split(/\r?\n/)
            .map((line) => line.replace(/\t/g, ',').trim())
            .filter(Boolean)
            .map((line) => line.split(',').map((part) => part.trim()))
            .map(([id, name]) => ({ id, name }))
            .filter((item) => item.id || item.name);
        }

        function renderRoster(){
          const textarea = $('rosterTextarea');
          const sorted = [...rosterStudents].sort((a, b) => a.id.localeCompare(b.id));
          textarea.value = sorted.map((item) => [item.id, item.name].filter(Boolean).join(', ')).join('\n');
          updateRosterCount(sorted.length);
        }

        function updateRosterCount(count){
          $('rosterCountLabel').textContent = `등록된 학생 ${count}명`;
        }

        function findRosterByName(name){
          const trimmed = (name || '').trim();
          if (!trimmed) return null;
          return rosterStudents.find((student) => (student.name || '').trim() === trimmed) || null;
        }

        async function attemptAutoLogin(){
          if (!authToken) {
            showLogin();
            return;
          }
          try {
            await loadConfig();
            await Promise.all([loadSessions(), loadRoster(), loadPublicSettings()]);
            showAdmin();
          } catch (error) {
            authToken = '';
            window.localStorage.removeItem('writingresearch_admin_token');
            showLogin();
          }
        }
        attemptAutoLogin();
      })();
    </script>
  </body>
</html>
